#평범한 배낭
#냅색 문제
#물품의 개수 n, 배낭의 허용 무게 k가 주어짐
#이후 각 물건의 무게 w와 가치 v가 주어짐
#배낭에 넣을 수 있는 물건의 최대 가치


n, k = map(int, input().split()) #물건의 갯수 n, 배낭의 허용 무게 k

stuff = [[0,0]] #물건 리스트

for i in range(n):
    stuff.append(list(map(int,input().split())))

dp = [[0] * (k + 1) for _ in range(n + 2)] 
#k + 1만큼의 열과 n + 1만큼의 행을 지닌 2차원 배열
#dp[n][k] = n번째 물건까지 배낭에 넣어본 상황을 탐색 후, 무게가 k일때의 최대값

for i in range(1, n + 1): #모든 물건 탐색
    w = stuff[i][0] #현재 물건의 무게
    v = stuff[i][1] #현재 물건의 가치

#이 부분이 핵심.. j는 현재 배낭에 넣을 수 있는 무게를 '가정'하는 수치
#ex) j가 3이라면 현재 배낭에 무게3을 넣을 수 있는 상황
#j는 0부터 k까지
#j가 w보다 작다면 배낭에 해당 물건을 넣을 수 없으므로 이전에 누적된 최대값을 불러옴
#물건을 넣을 수 있으면 (해당 물건의 무게를 뺀 무게의 최대가치와 해당 물건의 가치를 더한 가치) vs (현재 무게일 때의 최대가치 비교), 더 큰값을 저장
#ex) j가 7일 때 무게 4짜리 물건을 넣는 상황 : 무게 3일때의 최대가치(이전에 누적된)와 현재 물건의 가치를 더한 값 vs 무게 7일 때의 최대가치(이전에 누적된)
#이런식으로 진행하다보면 n번 까지의 물건을 모두 넣어봤을 때 무게가 k일때의 최대가치가 나옴
    for j in range(k+1): 
        if j < w:
            dp[i][j] = dp[i-1][j]
        else:
            dp[i][j] = max(dp[i-1][j], dp[i-1][j-w]+v)

print(dp[n][k])